
= 线程池

JVM 线程切换为 时间片轮转

== 线程数量

N 为 CPU 核心数

- CPU 密集型

    CPU使用率高，尽量使用较小的线程池

    N + 1

- IO 密集型

    CPU使用率不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间

    2N + 1

- 混合型

    将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理

    只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效

    因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，
    最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失

-- 摘自《Java Concurrency In Practise》

== 拒绝策略

. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
. CallerRunsPolicy：只用调用者所在的线程来处理任务
. DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
. DiscardPolicy：直接丢弃任务，也不抛出异常
