
= 回收算法

== 标记-清除

先标记，然后统一回收

缺点：

. 标记和清除的两个过程效率都不高
. 会产生大量的内存碎片

== 复制

内存空间分为两半 A 和 B

A <--> B

缺点：

. 空间利用率低，代价大

新生代就是采用的复制算法，Eden 和 Survivor的比例默认是 8 : 1，只浪费 10%

在新生代GC时，最坏的情况就是Eden区的所有对象都是存活的，那这个JVM会怎么处理呢？这里需要引入一个概念叫做 `内存分配担保`。

当发生了上面这种情况，新生代需要老年代的内存空间来做担保，把 Survivor 存放不下的对象直接存进老年代中。

== 标记-整理

类似于 标记-清理，整理操作是移动

== 分代收集

这也是当前主流虚拟机所采用的算法，其实就是针对不同的内存区域的特性，使用上面提到过的不同的算法。

新生代：的特性是大部分的对象都是需要被回收掉的，只有少量对象会存活下来。所以新生代一般都是采用复制算法。

老年代：属于对象存活率都很高的内存空间，则采用标记-清除和标记-整理算法来进行垃圾回收。
